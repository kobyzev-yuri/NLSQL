## Приоритезация, структура векторов и структура промпта

### Что такое приоритезация
Приоритезация — это политика выбора и ранжирования фрагментов знаний (документация, DDL, Q/A, инсайты) для контекста генерации SQL. Цель — дать модели максимально релевантный и компактный контекст.

Основные сигналы:
- Приоритет таблиц: частота использования в Q/A, роль в бизнес‑процессах, степень связности в join‑графе.
- Тип источника: DDL > целевые Q/A > структурированная документация > общая документация.
- Точность сопоставления: гибридный поиск (BM25 + эмбеддинги) и совпадения терминов (таблицы/колонки/статусы).

Где находится приоритезация сейчас:
- Код генерации инсайтов (join‑граф, ранжирование) создаёт документы `schema_insights` в `vanna_vectors` для повышения веса нужных таблиц.
- Исключены служебные таблицы (`vanna_*`, `chroma_*`, и т.п.) из анализа и контекста.
- В retrieval планируется учитывать: 1) попадание в whitelist приоритетных таблиц; 2) ранг по Q/A; 3) степень узла в join‑графе; 4) точные совпадения ключевых слов из вопроса.

### Структура данных для векторов (логическая схема записи)
Каждая запись в `vanna_vectors` содержит:
- content: текст (документ, DDL, Q/A, инсайт), возможно с префикс‑маркером источника.
- content_type: строка из множества {`documentation`, `ddl`, `question_sql`}.
- metadata (JSON):
  - type: дублирует роль записи (например, `documentation`, `ddl`, `question_sql`).
  - source: источник (`DocStructureSchema`, `training_data`, `schema_insights`, `live_db`).
  - filename: (опционально) имя файла источника.
  - kind: (для инсайтов) `join_graph` или `table_ranking`.
  - question/sql: (для Q/A) тексты вопроса и SQL.
  - tags: (опционально) список доменных тегов (`payments`, `users`, `assignments`).
- created_at: метка времени.

Минимальная DDL запись:
```
content: "CREATE TABLE tbl_incoming_payments (...);"
content_type: "ddl"
metadata: {"type":"ddl","source":"training_data"}
```

Q/A запись:
```
content: "Q: Покажи всех пользователей\nA: SELECT ... FROM equsers ..."
content_type: "question_sql"
metadata: {"type":"question_sql","source":"training_data","question":"...","sql":"..."}
```

Документация/инсайт:
```
content: "[DocStructureSchema:EQUsers.json]\n{...json...}"
content_type: "documentation"
metadata: {"type":"documentation","source":"DocStructureSchema","filename":"EQUsers.json"}
```

### Структура промпта для генерации SQL
Промпт формируется из блоков с явной приоритезацией:
1) Системные правила:
```
Ты помощник по SQL. Используй только существующие таблицы из контекста. Предпочитай поля из приоритетных таблиц. Учитывай связи из join‑графа. Диалект: PostgreSQL.
```
2) Контекст схемы (DDL + краткие описания приоритетных таблиц):
```
Таблица tbl_incoming_payments: колонки: id, payment_date, amount, ...
Таблица equsers: колонки: id, login, email, department, ...
```
3) Инсайты (join‑граф, топ‑таблицы):
```
Топ‑таблицы по использованию: tbl_incoming_payments, tbl_principal_assignment, ...
Возможные JOINы: tbl_incoming_payments.business_unit_id → tbl_business_unit.id
```
4) Примеры (few‑shot) — 1‑2 максимально релевантных Q/A:
```
Q: Платежи за месяц по клиентам
A: SELECT ...
```
5) Вопрос пользователя.

Принципы эффективности:
- Лимит контекста: жёсткая отсечка по количеству токенов; сжатие и агрегация DDL.
- Отбор контента: гибридный поиск + приоритетные таблицы + явные совпадения терминов.
- Баланс типов источников: минимум 1 DDL‑фрагмент для каждой таблицы в предполагаемом запросе, 1 инсайт по JOIN, 1 релевантный пример Q/A.

### План улучшений
- Ввести числовой скоринг документов: `score = α*BM25 + β*embedding + γ*usage_rank + δ*join_degree + ε*exact_hits`.
- Поддерживать whitelist/blacklist таблиц и колонок.
- Автогенерация кратких паспортов таблиц (описания колонок, PK/FK, примеры значений).
- Логи отбора контекста: сохранять, что попало в промпт и почему (для аудита/итераций).


